<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Tr√¨nh ph√°t B√†i gi·∫£ng ‚Äî Auto‚ÄëScroll B·∫≠t S·∫µn</title>
  <style>
    :root {
      --bar-bg: rgba(0, 0, 0, 0.7);
      --bar-fg: #ffffff;
      --accent: #0d6efd;
      --ok: #28a745;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      margin: 0;
      background: #000;
      overflow: hidden;
      /* tr·∫£i nghi·ªám xem slide */
    }

    .player-container {
      background: #fff;
      width: 100vw;
      height: 100dvh;
      display: flex;
      flex-direction: column;
      position: relative;
      /* ƒë·ªÉ ƒë·∫∑t thanh ƒëi·ªÅu khi·ªÉn */
    }

    /* Fallback cho Zalo/WebView kh√¥ng h·ªó tr·ª£ API Fullscreen */
    .player-container.pseudo-fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 99999;
      width: 100%;
      height: 100%;
      background: #000;
    }

    /* üî• FORCE LANDSCAPE MODE (Cho Mobile Portrait) */
    .player-container.force-landscape {
      position: fixed;
      top: 0;
      left: 100vw;
      /* ƒê·∫©y sang m√©p ph·∫£i ƒë·ªÉ xoay v·ªÅ */
      width: 100vh;
      height: 100vw;
      z-index: 99999;
      background: #000;
      transform-origin: top left;
      transform: rotate(90deg);
      /* ·∫®n thanh cu·ªôn m·∫∑c ƒë·ªãnh n·∫øu c√≥ */
      overflow: hidden;
    }

    .slide-viewer {
      border: 1px solid #ddd;
      border-radius: 8px;
      overflow-y: auto;
      flex-grow: 1;
      position: relative;
      background: #000;
    }

    .slide-viewer img {
      width: 100%;
      height: auto;
      display: block;
    }

    /* Ch·∫ø ƒë·ªô Fit (kh√¥ng cu·ªôn) */
    .slide-viewer.fit-mode {
      overflow: hidden;
    }

    .slide-viewer.fit-mode img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    /* Thanh ƒëi·ªÅu khi·ªÉn d∆∞·ªõi c√πng */
    .bottom-bar {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 10px;
      /* TƒÉng padding bottom cho c√°c d√≤ng iPhone ƒë·ªùi m·ªõi */
      padding-bottom: calc(10px + env(safe-area-inset-bottom));
      background: linear-gradient(to top, var(--bar-bg), transparent);
      transition: transform 0.35s ease-in-out;
      transform: translateY(0);
      color: var(--bar-fg);
    }

    /* ·∫®n thanh khi kh√¥ng t∆∞∆°ng t√°c */
    .player-container.inactive .bottom-bar {
      transform: translateY(100%);
    }

    .timeline-container {
      width: 100%;
      padding: 4px 0;
      margin-bottom: 6px;
    }

    .progress-bar-wrapper {
      background: rgba(255, 255, 255, 0.5);
      border-radius: 5px;
      cursor: pointer;
      padding: 4px 0;
    }

    .progress-bar {
      background: var(--accent);
      width: 0%;
      height: 8px;
      border-radius: 5px;
      transition: width 0.1s linear;
    }

    .time-display {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      margin-top: 4px;
      text-shadow: 1px 1px 2px #000;
    }

    .controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 2px;
      width: 100%;
      padding: 0 20%;
      /* Squeeze content to the center */
      box-sizing: border-box;
      /* Ensure padding is included in width */
    }

    .controls button {
      color: #fff;
      background: rgba(0, 0, 0, 0.3);
      border: none;
      border-radius: 50%;
      width: 44px;
      height: 44px;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.25s;
    }

    .controls button:hover {
      background: rgba(0, 0, 0, 0.45);
    }

    #play-pause-btn {
      background: var(--ok);
      width: 50px;
      height: 50px;
      font-size: 24px;
    }

    .slide-counter {
      flex: 1;
      text-align: center;
      font-weight: 700;
      text-shadow: 1px 1px 2px #000;
    }

    /* ===================== CSS M·ªöI CHO LOADING ===================== */
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fff;
      z-index: 10;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .loading-overlay.visible {
      visibility: visible;
      opacity: 1;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 1s infinite linear;
      margin-bottom: 10px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .loading-text {
      font-size: 14px;
      text-shadow: 1px 1px 2px #000;
    }

    /* ===================== VIDEO OVERLAY ===================== */
    .video-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      z-index: 200000;
      /* Must be higher than force-landscape (99999) */
      display: flex;
      flex-direction: column;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.3s;
    }

    /* Force Landscape for Video Overlay (Similar to Player Container) */
    .video-overlay.force-landscape {
      width: 100vh;
      height: 100vw;
      top: 0;
      left: 100vw;
      transform-origin: top left;
      transform: rotate(90deg);
    }

    .video-overlay.active {
      visibility: visible;
      opacity: 1;
    }

    .video-container {
      flex: 1;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .video-container iframe,
    .video-container video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      border: none;
      background: #000;
      outline: none;
    }

    .video-controls {
      position: absolute;
      top: 20px;
      left: 20px;
      /* Moved to Left to avoid conflicts */
      width: auto;
      height: auto;
      background: transparent;
      border: none;
      z-index: 20002;
      pointer-events: auto;
      /* Ensure clickable */
    }

    /* Manual Play Button for Mobile */
    .video-play-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.4);
      z-index: 20001;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .video-play-overlay.visible {
      visibility: visible;
      opacity: 1;
    }

    .big-play-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.9);
      color: #000;
      font-size: 40px;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }

    .close-video-btn {
      padding: 8px 16px;
      background: rgba(40, 167, 69, 0.8);
      /* Semi-transparent Green */
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 20px;
      font-size: 14px;
      cursor: pointer;
      font-weight: bold;
      backdrop-filter: blur(4px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      transition: all 0.2s ease;
    }

    .close-video-btn:hover {
      background: rgba(40, 167, 69, 1);
      transform: scale(1.05);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
    }
  </style>
</head>

<body>
  <div id="player-container" class="player-container">
    <div id="slide-viewer" class="slide-viewer" aria-label="Khu v·ª±c hi·ªÉn th·ªã slide" tabindex="0">
      <img id="slide-image" src="" alt="Slide" />
      <!-- Loading Overlay -->
      <div id="loading-overlay" class="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-text" class="loading-text">ƒêang t·∫£i d·ªØ li·ªáu...</div>
      </div>
    </div>



    <div class="bottom-bar">
      <div class="timeline-container">
        <div id="progress-bar-wrapper" class="progress-bar-wrapper">
          <div id="progress-bar" class="progress-bar"></div>
        </div>
        <div class="time-display">
          <span id="current-time">00:00</span>
          <span id="total-duration">00:00</span>
        </div>
      </div>

      <div class="controls">
        <button id="prev-btn" title="Slide tr∆∞·ªõc">‚è™</button>
        <button id="play-pause-btn" title="Ph√°t/T·∫°m d·ª´ng">‚ñ∂Ô∏è</button>
        <div id="slide-counter" class="slide-counter">‚Äî / ‚Äî</div>
        <button id="next-btn" title="Slide ti·∫øp theo">‚è©</button>
        <button id="autoscroll-btn" title="B·∫≠t/T·∫Øt T·ª± cu·ªôn">üîÑ</button>
        <button id="scale-btn" title="Ch·∫ø ƒë·ªô xem">‚õ∂</button>
        <button id="fullscreen-btn" title="To√†n m√†n h√¨nh">üñºÔ∏è</button>
      </div>
    </div>

    <!-- Audio Element ·∫©n -->
    <audio id="slide-audio" preload="auto"></audio>
  </div>

  <!-- Video Overlay (MOVED OUTSIDE) -->
  <div id="video-overlay" class="video-overlay">
    <div class="video-container">
      <!-- Native Video Element -->
      <video id="video-element" controls playsinline disablepictureinpicture controlsList="nodownload"></video>

      <!-- Manual Play Overlay -->
      <div id="video-play-overlay" class="video-play-overlay">
        <button id="big-play-btn" class="big-play-btn">‚ñ∂</button>
      </div>
    </div>
    <div class="video-controls">
      <button id="close-video-btn" class="close-video-btn">Next &gt;&gt;</button>
    </div>
  </div>

  <script>
    /* ===================== C·∫§U H√åNH ===================== */
    const TOTAL_SLIDES = 15;
    const IMAGE_PREFIX = 'images/slide-';
    const AUDIO_PREFIX = 'audio/slide_';
    const IMG_EXT = '.png';
    const AUD_EXT = '.mp3';

    /* ==================== QU·∫¢N L√ù T√ÄI NGUY√äN (New) ==================== */
    class ResourceManager {
      constructor() {
        this.cache = new Map(); // L∆∞u tr·ªØ tr·∫°ng th√°i load: 'loading', 'loaded', 'error'
        this.blobs = new Map(); // L∆∞u tr·ªØ Blob URL n·∫øu c·∫ßn (nh∆∞ng ·ªü ƒë√¢y ta preload qua Image/Audio obj)
        this.maxRetries = 5;
        this.retryDelay = 1500; // ms
        this.isZalo = /Zalo/i.test(navigator.userAgent); // Detect Zalo Browser
      }

      // T·∫°o key duy nh·∫•t cho resource
      getKey(type, index) { return `${type}_${index}`; }

      // T·∫£i ·∫£nh c√≥ retry
      loadImage(index) {
        const key = this.getKey('image', index);
        if (this.cache.has(key)) return this.cache.get(key);

        const src = `${IMAGE_PREFIX}${index}${IMG_EXT}`;
        const promise = new Promise((resolve, reject) => {
          let attempts = 0;

          const tryLoad = () => {
            attempts++;
            const img = new Image();
            img.src = src;
            img.onload = () => resolve(src); // Tr·∫£ v·ªÅ src g·ªëc v√¨ browser s·∫Ω cache
            img.onerror = () => {
              console.warn(`[Image] L·ªói t·∫£i slide ${index} (L·∫ßn ${attempts})`);
              if (attempts < this.maxRetries) {
                setTimeout(tryLoad, this.retryDelay * attempts); // Exponential backoff nh·∫π
              } else {
                reject(new Error(`Kh√¥ng th·ªÉ t·∫£i ·∫£nh slide ${index}`));
              }
            };
          };
          tryLoad();
        });

        this.cache.set(key, promise);
        return promise;
      }

      // T·∫£i audio c√≥ retry
      loadAudio(index) {
        const key = this.getKey('audio', index);
        if (this.cache.has(key)) return this.cache.get(key);

        const src = `${AUDIO_PREFIX}${index}${AUD_EXT}`;
        const promise = new Promise((resolve, reject) => {
          let attempts = 0;

          const tryLoad = () => {
            attempts++;
            // D√πng fetch ƒë·ªÉ ki·ªÉm tra ch·∫Øc ch·∫Øn file t·ªìn t·∫°i v√† t·∫£i v·ªÅ buffer d√≤ng ch·∫£y n·∫øu c·∫ßn
            // Tuy nhi√™n ƒë·ªÉ ƒë∆°n gi·∫£n v√† t·∫≠n d·ª•ng browser cache, ta d√πng Audio object
            const audio = new Audio();
            audio.preload = 'auto';
            audio.src = src;

            // X·ª≠ l√Ω s·ª± ki·ªán load
            const onSuccess = () => {
              cleanup();
              resolve(src);
            };
            const onError = () => {
              cleanup();
              console.warn(`[Audio] L·ªói t·∫£i audio ${index} (L·∫ßn ${attempts})`);
              if (attempts < this.maxRetries) {
                setTimeout(tryLoad, this.retryDelay * attempts);
              } else {
                reject(new Error(`Kh√¥ng th·ªÉ t·∫£i audio slide ${index}`));
              }
            };

            const cleanup = () => {
              audio.removeEventListener('canplaythrough', onSuccess);
              audio.removeEventListener('error', onError);
            };

            audio.addEventListener('canplaythrough', onSuccess); // ƒê·ªß d·ªØ li·ªáu ƒë·ªÉ ph√°t
            audio.addEventListener('error', onError);
            audio.load();
          };
          tryLoad();
        });

        this.cache.set(key, promise);
        return promise;
      }

      // T·∫£i c·∫£ b·ªô cho 1 slide
      loadSlide(index) {
        return Promise.all([
          this.loadImage(index),
          this.loadAudio(index)
        ]);
      }

      // M·ªöI: T·∫£i Video MP4 v√†o Cache (Blob)
      loadVideo(url) {
        // Zalo Fallback: Skip Blob, use Direct Stream to avoid errors
        if (this.isZalo) {
          console.log("[Video] Zalo detected. Skipping prefetch:", url);
          return Promise.resolve(url);
        }

        if (this.cache.has(url)) return this.cache.get(url);

        console.log("[Video] Prefetching:", url);
        const promise = fetch(url)
          .then(res => {
            if (!res.ok) throw new Error("Video load failed");
            return res.blob();
          })
          .then(blob => {
            const blobUrl = URL.createObjectURL(blob);
            this.blobs.set(url, blobUrl); // Store for retrieval
            return blobUrl;
          })
          .catch(err => {
            console.warn("[Video] Prefetch failed:", err);
            return url; // Fallback to original URL on error
          });

        this.cache.set(url, promise);
        return promise;
      }
    }

    /* ==================== BI·∫æN TO√ÄN C·ª§C ==================== */
    const resourceManager = new ResourceManager();
    const playerContainer = document.getElementById('player-container');
    const slideViewer = document.getElementById('slide-viewer');
    const slideImage = document.getElementById('slide-image');
    const slideAudio = document.getElementById('slide-audio');
    const loadingOverlay = document.getElementById('loading-overlay');
    const loadingText = document.getElementById('loading-text');

    // Video Elements
    const videoOverlay = document.getElementById('video-overlay');
    const videoElement = document.getElementById('video-element');
    const closeVideoBtn = document.getElementById('close-video-btn');
    const videoPlayOverlay = document.getElementById('video-play-overlay');
    const bigPlayBtn = document.getElementById('big-play-btn');
    const videoMap = new Map();

    const autoscrollBtn = document.getElementById('autoscroll-btn');
    const playPauseBtn = document.getElementById('play-pause-btn');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const slideCounter = document.getElementById('slide-counter');
    const scaleBtn = document.getElementById('scale-btn');
    const fullscreenBtn = document.getElementById('fullscreen-btn');
    const progressBarWrap = document.getElementById('progress-bar-wrapper');
    const progressBar = document.getElementById('progress-bar');
    const currentTimeEl = document.getElementById('current-time');
    const totalDurationEl = document.getElementById('total-duration');

    let isFitMode = false;
    let scrollAnimationId = null;
    let currentSlideIndex = 1; // Slide b·∫Øt ƒë·∫ßu t·ª´ 1
    let isAutoscrollEnabled = true;

    /* ================= UI HELPER ================= */
    function showLoading(show, message = "ƒêang t·∫£i...") {
      loadingText.textContent = message;
      if (show) loadingOverlay.classList.add('visible');
      else loadingOverlay.classList.remove('visible');
    }

    function syncAutoscrollUI() {
      autoscrollBtn.classList.toggle('active', isAutoscrollEnabled);
    }

    /* ================= VIDEO LOGIC ================= */
    const FALLBACK_VIDEO_DATA = ``;

    function parseVideoData(text) {
      const lines = text.split('\n');
      /* ... skipped unchanged regex logic ... */
      let currentSlide = null;

      lines.forEach(line => {
        line = line.trim();
        if (!line) return;

        // Match "Slide 12:"
        const slideMatch = line.match(/^Slide\s+(\d+)[:\s]*/i);
        if (slideMatch) {
          currentSlide = parseInt(slideMatch[1]);
          if (!videoMap.has(currentSlide)) {
            videoMap.set(currentSlide, { url: '', duration: 0, title: '' });
          }
        }
        else if (currentSlide !== null) {
          if (line.startsWith('http')) {
            let url = line;
            // MP4 Links: Direct use
            // Drive Links: Keep existing conversion logic just in case
            if (url.includes('drive.google.com') && url.includes('/view')) {
              url = url.replace('/view', '/preview');
            }
            const data = videoMap.get(currentSlide);
            if (data) data.url = url;
          }
          // ... duration logic remains same
          else if (line.match(/^Duration[:\s]+/i)) {
            /* ... */
            const data = videoMap.get(currentSlide);
            if (data) {
              // Try "1:58"
              const timeMatch = line.match(/Duration[:\s]+(\d+):(\d+)/i);
              if (timeMatch) {
                const m = parseInt(timeMatch[1]);
                const s = parseInt(timeMatch[2]);
                data.duration = m * 60 + s;
              } else {
                const secMatch = line.match(/Duration[:\s]+(\d+)/i);
                if (secMatch) {
                  data.duration = parseInt(secMatch[1]);
                }
              }
            }
          }
          else {
            /* ... title logic ... */
            const data = videoMap.get(currentSlide);
            if (data && !data.title && !line.startsWith('Duration')) {
              data.title = line;
            }
          }
        }
      });
      console.log("Loaded Videos:", videoMap);
    }

    async function loadVideoLinks() {
      try {
        const response = await fetch('videoLink.txt');
        if (!response.ok) throw new Error("Cannot fetch videoLink.txt");
        const text = await response.text();
        parseVideoData(text);
      } catch (e) {
        console.warn("Fetch failed (likely CORS), using fallback data:", e);
        parseVideoData(FALLBACK_VIDEO_DATA);
      }
    }

    let videoTimer = null;

    async function playVideo(videoData) {
      let url = videoData.url;
      console.log("Preparing Video:", url);

      // Check Cache First
      if (resourceManager.blobs.has(url)) {
        console.log("üöÄ Using Cached MP4 Blob!");
        url = resourceManager.blobs.get(url);
      } else if (resourceManager.cache.has(url)) {
        // Waiting for pending fetch
        try {
          console.log("‚è≥ Waiting for pending download...");
          url = await resourceManager.cache.get(url);
        } catch (e) { /* Error handled in cached promise */ }
      }

      videoElement.src = url;
      videoOverlay.classList.add('active');
      videoPlayOverlay.classList.remove('visible'); // Hide manual play button initially

      slideAudio.pause();
      cancelAnimationFrame(scrollAnimationId);

      // Setup Manual Play Interaction
      const triggerPlay = async (e) => {
        // Fail-safe: Hide overlay IMMEDIATELY so user can access native controls if script fails
        videoPlayOverlay.classList.remove('visible');

        if (e && e.stopPropagation) e.stopPropagation();

        try {
          await videoElement.play();
        } catch (e) {
          console.error("Play failed (User can now use native controls)", e);
        }
      };

      videoPlayOverlay.onclick = triggerPlay;
      bigPlayBtn.onclick = triggerPlay;

      // Play Logic with Muted Fallback
      try {
        await videoElement.play();
      } catch (e) {
        console.warn("Autoplay with sound failed. Retrying muted...", e);
        try {
          // Mobile Browser often allow autoplay if MUTED
          videoElement.muted = true;
          await videoElement.play();
          console.log("Muted autoplay started.");
          videoPlayOverlay.classList.remove('visible'); // Success! Hide overlay
        } catch (errMuted) {
          console.error("Muted autoplay also failed.", errMuted);
          // Only NOW show the big manual play button
          videoPlayOverlay.classList.add('visible');
        }
      }

      // Native Auto-Advance
      videoElement.onended = () => {
        console.log("Video ended. Auto-advancing.");
        closeVideo();
      };

      videoElement.onplay = () => {
        videoPlayOverlay.classList.remove('visible');
      };
    }

    function closeVideo() {
      videoOverlay.classList.remove('active');
      videoElement.pause();
      videoElement.src = ""; // Stop buffering
      videoElement.onended = null; // Cleanup listener

      // Chuy·ªÉn slide ti·∫øp theo
      if (currentSlideIndex < TOTAL_SLIDES) {
        showSlide(currentSlideIndex + 1);
      }
    }

    closeVideoBtn.addEventListener('click', closeVideo);

    /* ================= LOGIC CH√çNH ================= */
    async function showSlide(index) {
      // Validate index
      if (index < 1) index = 1;
      if (index > TOTAL_SLIDES) index = TOTAL_SLIDES;
      currentSlideIndex = index;

      // Stop current playback
      slideAudio.pause();
      cancelAnimationFrame(scrollAnimationId);
      showLoading(true, `ƒêang t·∫£i slide ${index}...`);

      // Update n√∫t ƒëi·ªÅu h∆∞·ªõng
      prevBtn.disabled = (index === 1);
      nextBtn.disabled = (index === TOTAL_SLIDES);
      slideCounter.textContent = `${index} / ${TOTAL_SLIDES}`;

      try {
        // 1. T·∫£i resources c·ªßa slide hi·ªán t·∫°i (ho·∫∑c l·∫•y t·ª´ cache)
        await resourceManager.loadSlide(index);

        // 2. G√°n source (l√∫c n√†y ƒë√£ n·∫±m trong cache tr√¨nh duy·ªát)
        slideImage.src = `${IMAGE_PREFIX}${index}${IMG_EXT}`;
        slideAudio.src = `${AUDIO_PREFIX}${index}${AUD_EXT}`;

        // 3. Reset view
        slideViewer.scrollTop = 0;
        showLoading(false);

        // 4. Ph√°t audio & Auto-scroll
        try {
          await slideAudio.play();
          startAutoScrollIfNeeded();
        } catch (err) {
          console.log("Autoplay blocked or waiting for interaction", err);
          playPauseBtn.innerHTML = '‚ñ∂Ô∏è'; // Hi·ªÉn th·ªã n√∫t play
        }

        // 5. Preload c√°c slide ti·∫øp theo (Chi·∫øn l∆∞·ª£c th√¥ng minh)
        preloadNextSlides(index);

      } catch (error) {
        console.error(error);
        showLoading(true, "M·∫°ng kh√¥ng ·ªïn ƒë·ªãnh. ƒêang th·ª≠ l·∫°i...");
        // T·ª± ƒë·ªông th·ª≠ l·∫°i sau 3s n·∫øu l·ªói
        setTimeout(() => showSlide(index), 3000);
      }
    }

    function preloadNextSlides(currentIndex) {
      // 1. Preload 2 slide ti·∫øp theo (·∫¢nh + Audio)
      for (let i = 1; i <= 2; i++) {
        const nextIdx = currentIndex + i;
        if (nextIdx <= TOTAL_SLIDES) {
          resourceManager.loadSlide(nextIdx).catch(err => console.log(`Preload failed for ${nextIdx}`, err));
        }
      }

      // 2. Preload Video (n·∫øu c√≥ ·ªü slide k·∫ø ti·∫øp)
      const nextSlideIndex = currentIndex + 1;
      if (videoMap.has(nextSlideIndex)) {
        const vidData = videoMap.get(nextSlideIndex);
        if (vidData && vidData.url && vidData.url.endsWith('.mp4')) {
          resourceManager.loadVideo(vidData.url);
        }
      }
    }

    /* ================== AUTO SCROLL & AUDIO ================== */
    function startAutoScrollIfNeeded() {
      if (isAutoscrollEnabled && !isFitMode && !slideAudio.paused && !slideAudio.ended) {
        cancelAnimationFrame(scrollAnimationId);
        scrollAnimationId = requestAnimationFrame(autoScroll);
      }
    }

    function autoScroll() {
      if (!isAutoscrollEnabled || isFitMode || slideAudio.paused || slideAudio.ended) return;
      const dur = slideAudio.duration || 0;
      const cur = slideAudio.currentTime || 0;
      if (dur > 0) {
        const scrollable = slideViewer.scrollHeight - slideViewer.clientHeight;
        const top = (cur / dur) * scrollable;
        slideViewer.scrollTop = top;
      }
      scrollAnimationId = requestAnimationFrame(autoScroll);
    }

    /* ================= LISTENERS ================= */
    slideAudio.addEventListener('play', () => {
      playPauseBtn.innerHTML = '‚è∏Ô∏è';
      startAutoScrollIfNeeded();
    });
    slideAudio.addEventListener('pause', () => {
      playPauseBtn.innerHTML = '‚ñ∂Ô∏è';
      cancelAnimationFrame(scrollAnimationId);
    });
    slideAudio.addEventListener('ended', () => {
      // Ki·ªÉm tra xem slide hi·ªán t·∫°i c√≥ video link kh√¥ng
      if (videoMap.has(currentSlideIndex)) {
        playVideo(videoMap.get(currentSlideIndex));
      } else {
        // Normal flow
        if (currentSlideIndex < TOTAL_SLIDES) {
          showSlide(currentSlideIndex + 1);
        }
      }
    });

    // Time Update & Progress Bar
    slideAudio.addEventListener('timeupdate', () => {
      if (!isNaN(slideAudio.duration) && slideAudio.duration > 0) {
        const pct = (slideAudio.currentTime / slideAudio.duration) * 100;
        progressBar.style.width = `${pct}%`;
        currentTimeEl.textContent = formatTime(slideAudio.currentTime);
      }
    });
    slideAudio.addEventListener('loadedmetadata', () => {
      if (!isNaN(slideAudio.duration)) totalDurationEl.textContent = formatTime(slideAudio.duration);
    });

    // Seek
    progressBarWrap.addEventListener('click', (ev) => {
      if (!slideAudio.duration) return;
      const rect = progressBarWrap.getBoundingClientRect();
      const ratio = (ev.clientX - rect.left) / rect.width;
      slideAudio.currentTime = ratio * slideAudio.duration;
    });

    // Buttons
    playPauseBtn.addEventListener('click', () => {
      if (slideAudio.paused) slideAudio.play();
      else slideAudio.pause();
    });

    prevBtn.addEventListener('click', () => {
      if (currentSlideIndex > 1) showSlide(currentSlideIndex - 1);
    });

    nextBtn.addEventListener('click', () => {
      if (currentSlideIndex < TOTAL_SLIDES) showSlide(currentSlideIndex + 1);
    });

    autoscrollBtn.addEventListener('click', () => {
      isAutoscrollEnabled = !isAutoscrollEnabled;
      syncAutoscrollUI();
      if (isAutoscrollEnabled) startAutoScrollIfNeeded();
      else cancelAnimationFrame(scrollAnimationId);
    });

    scaleBtn.addEventListener('click', () => {
      isFitMode = !isFitMode;
      slideViewer.classList.toggle('fit-mode', isFitMode);
      scaleBtn.innerHTML = isFitMode ? '‚ÜïÔ∏è' : '‚õ∂';
      if (isFitMode) cancelAnimationFrame(scrollAnimationId);
      else startAutoScrollIfNeeded();
    });

    // Fullscreen logic c·∫£i ti·∫øn cho Zalo
    function toggleFullscreen() {
      // Ki·ªÉm tra xem c√≥ ƒëang ·ªü ch·∫ø ƒë·ªô pseudo-fullscreen kh√¥ng
      const isPseudo = playerContainer.classList.contains('pseudo-fullscreen');
      const isNative = !!document.fullscreenElement;

      if (!isNative && !isPseudo) {
        // Th·ª≠ b·∫≠t fullscreen native
        document.documentElement.requestFullscreen()
          .then(() => {
            // Th√†nh c√¥ng native
            screen.orientation.lock('landscape').catch(() => { });
          })
          .catch(err => {
            console.log("Fullscreen native b·ªã ch·∫∑n, chuy·ªÉn sang ch·∫ø ƒë·ªô gi·∫£ l·∫≠p (Zalo/Webview)", err);
            // Fallback: Maximize container b·∫±ng CSS
            playerContainer.classList.add('pseudo-fullscreen');
            fullscreenBtn.innerHTML = 'X';

            // √âp xoay ngang n·∫øu c√≥ th·ªÉ
            if (screen.orientation && typeof screen.orientation.lock === 'function') {
              screen.orientation.lock('landscape').catch(() => { });
            }
          });
      } else {
        // ƒêang full (native ho·∫∑c pseudo) -> Tho√°t
        if (isNative) {
          document.exitFullscreen();
        }
        playerContainer.classList.remove('pseudo-fullscreen');
        fullscreenBtn.innerHTML = 'üñºÔ∏è';

        if (screen.orientation && typeof screen.orientation.unlock === 'function') {
          screen.orientation.unlock();
        }
      }
    }
    fullscreenBtn.addEventListener('click', toggleFullscreen);

    // L·∫Øng nghe thay ƒë·ªïi native ƒë·ªÉ c·∫≠p nh·∫≠t n√∫t v√† class
    document.addEventListener('fullscreenchange', () => {
      if (!document.fullscreenElement) {
        // Ng∆∞·ªùi d√πng tho√°t b·∫±ng n√∫t ESC ho·∫∑c vu·ªët
        playerContainer.classList.remove('pseudo-fullscreen');
        fullscreenBtn.innerHTML = 'üñºÔ∏è';
      } else {
        fullscreenBtn.innerHTML = 'X';
      }
    });

    // Controls Visibility
    let inactivityTimer;
    function showControlsAndResetTimer() {
      playerContainer.classList.remove('inactive');
      clearTimeout(inactivityTimer);
      inactivityTimer = setTimeout(() => {
        if (!slideAudio.paused) playerContainer.classList.add('inactive');
      }, 3000);
    }
    playerContainer.addEventListener('mousemove', showControlsAndResetTimer);
    playerContainer.addEventListener('click', showControlsAndResetTimer);
    playerContainer.addEventListener('touchstart', showControlsAndResetTimer);

    // Helpers
    function formatTime(sec) {
      const m = Math.floor(sec / 60);
      const s = Math.floor(sec % 60);
      return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }

    /* ================= üî• T·ª∞ ƒê·ªòNG XOAY NGANG (FORCED LANDSCAPE) ================= */
    function checkOrientation() {
      // Ph√°t hi·ªán thi·∫øt b·ªã di ƒë·ªông c∆° b·∫£n
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

      // N·∫øu l√† mobile V√Ä m√†n h√¨nh ƒëang ·ªü chi·ªÅu d·ªçc (cao > r·ªông)
      if (isMobile && window.innerHeight > window.innerWidth) {
        playerContainer.classList.add('force-landscape');
        videoOverlay.classList.add('force-landscape');
      } else {
        playerContainer.classList.remove('force-landscape');
        videoOverlay.classList.remove('force-landscape');
      }
    }

    // L·∫Øng nghe s·ª± ki·ªán xoay v√† resize
    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);

    /* ================= INIT ================= */
    window.addEventListener('load', () => {
      loadVideoLinks(); // T·∫£i link video
      showControlsAndResetTimer();
      syncAutoscrollUI();
      checkOrientation(); // Ki·ªÉm tra h∆∞·ªõng ngay khi t·∫£i
      // B·∫Øt ƒë·∫ßu
      showSlide(currentSlideIndex);
    });
  </script>
</body>

</html>